/*
 *	Copyright © 2016 tastytea <tastytea@tastytea.de>
 *
 *	This file is part of seriespl.
 *
 *	seriespl is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, version 2 of the License.
 *
 *	seriespl is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with seriespl. If not, see <http://www.gnu.org/licenses/>.
 *
 ******************************************************************************/


<<<<<<< HEAD
/*! \page seriespl
	Extract stream-URLs for entire seasons of tv series from bs.to 
	
	\section SYNOPSIS
	seriespl [-h] [-i]|[-p list] [-e episodes] [-s seasons] [-f format] URL
	
	\section DESCRIPTION
	__seriespl__ extracts stream-URLs for entire seasons of tv series from bs.to
	(Burning-Series). These URLs can then be further processed by e.g. youtube-dl or mpv.
	
	\section OPTIONS
	\b -h \n
	Show help

	\b -p  <em>STREAM PROVIDERS</em> \n
	Comma delimited list. Available:
	Streamcloud,Vivo,Shared,YouTube,OpenLoad,PowerWatch,CloudTime,AuroraVid,Vidto

	\b -i \n
	Use stream providers without SSL support too
	
	\b -e \e EPISODES \n
	Episode range, e.g. 2-5 or 7 or 9-, use c for current

	\b -s \e SEASONS \n
	Season range, e.g. 1-2 or 4

	\b -f \e FORMAT \n
	Playlist format. Available: raw, m3u, pls

	\b -y \n
	Use youtube-dl to print the direct URL of the video file

	\b -V \n
	Output version and copyright information and exit

	\section EXAMPLES
	Download all episodes of South Park Season 1-3:
	\code
	seriespl -s 1-3 https://bs.to/serie/South-Park | youtube-dl -a -
	\endcode

	Watch all episodes starting from 6 of South Park Season 1:
	\code
	seriespl -e 6- https://bs.to/serie/South-Park/1 | mpv --playlist=-
	\endcode

	Create an M3U playlist of Southpark Season 2 using only Streamcloud and Shared:
	\code
	seriespl -s 2 -f m3u -p Streamcloud,Shared https://bs.to/serie/South-Park > playlist.m3u
	\endcode

	Watch only current Episode in vlc, with correct title:
	\code
	seriespl -i -e c -y -f m3u https://bs.to/serie/South-Park/1/1-Cartman-und-die-Analsonde | vlc -
	\endcode

	\section CONFIGURATION
	Place the config file in ${XDG_CONFIG_HOME}/seriespl.cfg or ${HOME}/.config/seriespl.cfg.
	Values must be surrounded by quotes.

	\subsection streamproviders
	Comma delimited list of streamproviders. Default: "Streamcloud,Vivo,Shared,YouTube,OpenLoad"

	\subsection youtube-dl
	Path to youtube-dl. Default: "youtube-dl"

	\section COPYRIGHT
	Copyright © 2016 tastytea \<tastytea@tastytea.de\>. License GPLv2: GNU GPL version 2
	\<http://www.gnu.org/licenses/gpl-2.0.html\>.\n
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law. */

#include <memory>
#include <iostream>
#include <string>
#include <regex>
#include <iterator>
#include <vector>
#include <sstream>
#include <unistd.h>
#include <getopt.h>
#include <limits>
#include <map>
#include <utility>
#include <cstdio>

#include "http.hpp"
#include "config.hpp"

const std::string version = "1.4.5";
enum Services
{ // Services who provide links to entire seasons
	BurningSeries
};
Services service;

enum StreamProviders
{ // Available stream providers
	Streamcloud,
	Vivo,
	Shared,
	YouTube,
	OpenLoad,
	PowerWatch,
	CloudTime,
	AuroraVid,
	Vidto
};
std::vector<StreamProviders> Providers;	// List of active stream providers

typedef const std::pair <std::string, std::string> providerpair; // Name and domain
const std::map<StreamProviders, providerpair> providermap =
{ // Map stream providers to string and URL
	{Streamcloud, providerpair("Streamcloud", "streamcloud.eu")},
	{Vivo, providerpair("Vivo", "vivo.sx")},
	{Shared, providerpair("Shared", "shared.sx")},
	{YouTube, providerpair("YouTube", "www.youtube.com")},
	{OpenLoad, providerpair("OpenLoad", "openload.co")},
	{PowerWatch, providerpair("PowerWatch", "powerwatch.pw")},
	{CloudTime, providerpair("CloudTime", "www.cloudtime.to")},
	{AuroraVid, providerpair("AuroraVid", "auroravid.to")},
	{Vidto, providerpair("Vidto", "vidto.me")}
};

enum PlaylistFormat
{
	PL_RAW,
	PL_M3U,
	PL_PLS
};

std::string yt_dl_path = "youtube-dl";

void populate_providers(const std::string &providerlist)
{
	std::istringstream ss;

	ss.str(providerlist);
	Providers.clear();

	std::regex reConfig("([[:alnum:]]+)");
	std::sregex_iterator it_re(providerlist.begin(), providerlist.end(), reConfig);
	std::sregex_iterator it_re_end;

	while (it_re != it_re_end)
	{
		std::map<StreamProviders, providerpair>::const_iterator it;
		for (it = providermap.begin(); it != providermap.end(); ++it)
		{
			if (it->second.first == (*it_re)[1])
				Providers.push_back(it->first);
		}
		++it_re;
	}
	if (Providers.empty())
	{
		std::cerr << "Error: List of streaming providers is empty." << std::endl;
		exit(2);
	}
}

std::string getlink(const std::string &url, const StreamProviders &provider, std::string &title)
{ // Takes URL of episode-page and streaming provider, returns URL of stream-page or "" on error
	std::string content = getpage(url);
	std::string streamurl = "";

	if (service == BurningSeries)
	{
		std::regex reStreamPage("(<a href| src)=[\"\'](https?://" +
			providermap.at(provider).second + "/.*)[\"\']( target=|></iframe>)");
		std::regex reTitle(
			std::string("<h2 id=\"titleGerman\">(.*)") +
				"[[:space:]]+<small id=\"titleEnglish\" lang=\"en\">(.*)</small>");
		std::smatch match;

		if (std::regex_search(content, match, reStreamPage))
		{
			streamurl = match[2].str();
			
			if (provider == Streamcloud ||
				provider == Vivo ||
				provider == Shared ||
				provider == YouTube)
			{ // Make sure we use SSL where supported
				if (streamurl.find("https") == std::string::npos)
				{
					streamurl = "https" + streamurl.substr(4, std::string::npos);
				}
			}
		}
		else
		{
			std::cerr << "Error extracting stream" << std::endl;
		}

		if (std::regex_search(content, match, reTitle))
		{
			if (match[1].str() != "")		// German
				title = match[1].str();
			else if (match[2].str() != "")	// English
				title = match[2].str();
		}
	} // service-if

	return streamurl;
}

std::string getlink(const std::string &url, const StreamProviders &provider)
{
	std::string title;
	return getlink(url, provider, title);
}

void print_playlist(const PlaylistFormat &playlist, const std::string &url,
					const std::string &title)
{
	static unsigned short counter = 1;
	std::string newtitle = title;
	size_t pos = 0;

	switch (playlist)
	{
		case PL_RAW:
			std::cout << url << std::endl;
			break;
		case PL_M3U:
			if (counter == 1) // Write header
			{
				std::cout << "#EXTM3U" << std::endl;
			}
			// Replacing comma with U+201A, SINGLE LOW-9 QUOTATION MARK
			// Because VLC uses commas in titles as separator for metadata
			while ((pos = title.find(',', pos + 1)) != std::string::npos)
			{
				newtitle.replace(pos, 1, "‚");
			}
			std::cout << "#EXTINF:-1," << newtitle << std::endl;
			std::cout << url << std::endl;
			break;
		case PL_PLS:
			if (counter == 1) // Write header
			{
				std::cout << "[playlist]" << std::endl;
				std::cout << "Version=2" << std::endl;
			}
			if (url == "NUMBER_OF_EPISODES")
			{
				std::cout << "NumberOfEntries=" << counter - 1 << std::endl;
			}
			else
			{
				std::cout << "File" << counter << "=" << url << std::endl;
				std::cout << "Title" << counter << "=" << title << std::endl;
				std::cout << "Length" << counter << "=-1" << std::endl;
			}
			break;
	}
	++counter;
}

void print_playlist(const PlaylistFormat &playlist, const std::string &url)
{
	return print_playlist(playlist, url, "");
}

std::string get_direct_url(std::string &providerurl)
{ // Use youtube-dl to print the direct URL of the video file
	FILE *ytdl;
	char buffer[256];
	std::string result;

	if(!(ytdl = popen(( yt_dl_path + " --get-url " + providerurl).c_str(), "r")))
	{
		std::cerr << "Error: Can not spawn process for youtube-dl" << std::endl;
		return "";
	}

	while(fgets(buffer, sizeof(buffer), ytdl) != NULL)
	{
		result += buffer;
	}
	if (pclose(ytdl) != 0)
	{
		std::cerr << "Error: youtube-dl returned non-zero exit code" << std::endl;
		return "";
	}

	return result.substr(0, result.find_last_not_of("\r\n") + 1);
}
=======
#include "seriespl.hpp"
>>>>>>> reorganize

int main(int argc, char const *argv[])
{
	Seriespl app(argc, argv);

	return app.run();
}
